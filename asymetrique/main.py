import random
import string
import hashlib
import base64
import math
import json
import os
import sys

# Ajout du chemin pour pouvoir importer les modules de chiffrement sym√©trique
# Nous avons besoin de garder cet import pour le chiffrement des cl√©s priv√©es
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from symetrique.modules import prim as sym_prim

# --------------------------
#  Fonctions utilitaires
# --------------------------

def demand_msg():
    while True:
        msg = input("\nMon message : ")
        if not msg:
            print("‚ùå  Le message ne peut pas √™tre vide.")
            continue
        return msg

def demand_key():
    while True:
        key_str = input("\nMa cl√© (format : 123,456 ou (123, 456)) : ").strip()
        
        # Nettoie les parenth√®ses s'il y en a
        if key_str.startswith("(") and key_str.endswith(")"):
            key_str = key_str[1:-1]

        parts = key_str.split(",")

        if len(parts) != 2:
            print("‚ùå Format invalide. Attendu : deux entiers s√©par√©s par une virgule.")
            continue

        try:
            e_or_d = int(parts[0].strip())
            n = int(parts[1].strip())
            return (e_or_d, n)
        except ValueError:
            print("‚ùå La cl√© doit contenir deux entiers.")

def demand_username():
    username = input("\nQui √™tes-vous ? (nom d'utilisateur) : ")
    return username.strip()

def demand_symmetric_key():
    while True:
        key = input("\nEntrez votre cl√© de protection (pour le chiffrement sym√©trique) : ")
        if not key:
            print("‚ùå La cl√© ne peut pas √™tre vide.")
            continue
        return key

def demand_cipher_b64():
    while True:
        msg = input("\nMon message chiffr√© : ")
        if not msg:
            print("‚ùå  Le message chiffr√© ne peut pas √™tre vide.")
            continue
        return msg

def gcd(a, b):
    """PGCD avec l'algorithme d'Euclide."""
    while b != 0:
        a, b = b, a % b
    return a

def modinv(e, phi_n):
    """
    Calcule l'inverse modulaire de e modulo phi_n de mani√®re plus efficace.
    Utilise l'algorithme d'Euclide √©tendu.
    """
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        else:
            gcd, x, y = extended_gcd(b % a, a)
            return gcd, y - (b // a) * x, x
    
    gcd, x, y = extended_gcd(e, phi_n)
    
    if gcd != 1:
        return None  # L'inverse modulaire n'existe pas
    else:
        return x % phi_n

def is_prime(num):
    """Test de primalit√© simple."""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def generate_salt(length=16):
    """G√©n√®re un sel al√©atoire."""
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def simple_hash(message):
    """SHA-256 du message."""
    return hashlib.sha256(message.encode('utf-8')).hexdigest()

# --------------------------
#  Gestion des utilisateurs et cl√©s
# --------------------------

def get_keys_path():
    """Chemin vers le fichier de cl√©s"""
    return os.path.join(os.path.dirname(os.path.abspath(__file__)), "users_keys.json")

def load_user_keys():
    """Charge les cl√©s des utilisateurs depuis le fichier JSON"""
    keys_path = get_keys_path()
    if not os.path.exists(keys_path):
        return {}
    
    try:
        with open(keys_path, "r") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return {}

def save_user_keys(users_keys):
    """Enregistre les cl√©s des utilisateurs dans le fichier JSON"""
    keys_path = get_keys_path()
    os.makedirs(os.path.dirname(keys_path), exist_ok=True)
    
    with open(keys_path, "w") as f:
        json.dump(users_keys, f, indent=4)

def user_exists(username):
    """V√©rifie si un utilisateur existe d√©j√†"""
    users_keys = load_user_keys()
    return username in users_keys

def get_user_keys(username):
    """R√©cup√®re les cl√©s d'un utilisateur"""
    users_keys = load_user_keys()
    return users_keys.get(username, None)

def get_decrypted_private_key(username, sym_key):
    """R√©cup√®re et d√©chiffre la cl√© priv√©e d'un utilisateur"""
    user_data = get_user_keys(username)
    if not user_data:
        print(f"‚ùå Utilisateur {username} introuvable.")
        return None
    
    # D√©chiffrement de la cl√© priv√©e avec la cl√© sym√©trique
    encrypted_private_key = user_data["encrypted_private_key"]
    
    try:
        # D√©chiffrer la repr√©sentation JSON de la cl√© priv√©e
        decrypted_json = sym_prim.dechiffrer(encrypted_private_key, sym_key)
        if decrypted_json.startswith("Erreur"):
            print(f"‚ùå {decrypted_json}")
            return None
            
        # Convertir la cha√Æne JSON en tuple
        try:
            # Essayer de charger en tant que JSON
            key_data = json.loads(decrypted_json)
            return (key_data[0], key_data[1])
        except json.JSONDecodeError:
            print("‚ùå Erreur de d√©codage de la cl√© priv√©e.")
            return None
    except Exception as e:
        print(f"‚ùå Erreur lors du d√©chiffrement de la cl√© priv√©e: {str(e)}")
        return None

def register_new_user(username):
    """Enregistre un nouvel utilisateur avec ses cl√©s"""
    print(f"\nüîê G√©n√©ration des cl√©s pour {username}...")
    public_key, private_key = generate_keys()
    
    # Demander une cl√© sym√©trique pour prot√©ger la cl√© priv√©e
    sym_key = demand_symmetric_key()
    
    # Convertir le tuple de cl√© priv√©e en JSON pour le chiffrement
    private_key_json = json.dumps(private_key)
    
    # Chiffrer la cl√© priv√©e avec le chiffrement sym√©trique
    encrypted_private_key = sym_prim.chiffrer(private_key_json, sym_key)
    
    # Enregistrer les cl√©s
    users_keys = load_user_keys()
    users_keys[username] = {
        "public_key": public_key,
        "encrypted_private_key": encrypted_private_key
    }
    save_user_keys(users_keys)
    
    print(f"‚úÖ Cl√©s g√©n√©r√©es et enregistr√©es pour {username}")
    print(f"üîë Cl√© publique (e, n) = {public_key}")
    print(f"‚ö†Ô∏è Votre cl√© priv√©e est prot√©g√©e par chiffrement sym√©trique.")
    print(f"‚ö†Ô∏è N'oubliez pas votre cl√© de protection sym√©trique!")
    
    return public_key

# --------------------------
#  G√©n√©ration de cl√©s RSA
# --------------------------

def generate_keys(key_size=512):
    """
    G√©n√®re une paire de cl√©s RSA de taille sp√©cifi√©e de mani√®re optimis√©e.
    
    Args:
        key_size (int): Taille approximative de la cl√© en bits (par d√©faut 512)
    
    Returns:
        tuple: ((e, n), (d, n)) - cl√© publique et cl√© priv√©e
    """
    # Taille des nombres premiers (la moiti√© de la taille de la cl√©)
    bit_size = key_size // 2
    
    print(f"‚è≥ G√©n√©ration de nombres premiers ({bit_size} bits)...")
    
    # G√©n√©rer deux nombres premiers distincts
    p = generate_prime(bit_size)
    q = generate_prime(bit_size)
    
    # S'assurer que p et q sont distincts
    while p == q:
        q = generate_prime(bit_size)
    
    print("‚úÖ Nombres premiers g√©n√©r√©s!")
    
    # Calculer n et phi(n)
    n = p * q
    phi_n = (p - 1) * (q - 1)
    
    # Exposant public standard: 65537 (0x10001)
    e = 65537
    
    # V√©rifier que e est premier avec phi_n
    while gcd(e, phi_n) != 1:
        # Choisir un autre exposant si n√©cessaire (rare)
        e = 65539  # Prochain nombre premier apr√®s 65537
        
        if gcd(e, phi_n) != 1:
            e = 65521  # Plus grand nombre premier inf√©rieur √† 65536
            
            # Si toujours pas, utiliser une recherche plus √©tendue
            if gcd(e, phi_n) != 1:
                e = find_coprime(phi_n)
    
    # Calculer l'exposant priv√© d
    d = efficient_modinv(e, phi_n)
    
    # Double v√©rification: e*d ‚â° 1 (mod phi_n)
    assert (e * d) % phi_n == 1, "Erreur dans le calcul de l'inverse modulaire"
    
    return (e, n), (d, n)

def generate_prime(bits):
    """
    G√©n√®re un nombre premier de la taille sp√©cifi√©e en bits
    en utilisant une approche optimis√©e.
    """
    # Liste des petits nombres premiers pour un test de divisibilit√© rapide
    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    
    # Garantir que le nombre est dans la plage correcte: [2^(bits-1), 2^bits - 1]
    min_val = 1 << (bits - 1)
    max_val = (1 << bits) - 1
    
    while True:
        # G√©n√©rer un nombre impair dans la plage
        candidate = random.randrange(min_val, max_val) | 1
        
        # Test rapide de divisibilit√© par les petits nombres premiers
        is_divisible = False
        for prime in small_primes:
            if candidate % prime == 0 and candidate > prime:
                is_divisible = True
                break
        
        if is_divisible:
            continue
        
        # Test de Miller-Rabin avec 7 it√©rations (probabilit√© d'erreur < 2^-56)
        if is_probable_prime(candidate, 7):
            return candidate

def is_probable_prime(n, k=7):
    """
    Test de primalit√© de Miller-Rabin optimis√©.
    
    Args:
        n: Nombre √† tester
        k: Nombre d'it√©rations (plus k est grand, plus le test est pr√©cis)
    
    Returns:
        bool: True si n est probablement premier, False s'il est compos√©
    """
    if n == 2 or n == 3:
        return True
    if n <= 1 or n % 2 == 0:
        return False
    
    # √âcrire n-1 comme d*2^r
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    
    # T√©moins pour le test de Miller-Rabin
    # Pour n < 2‚Å∂‚Å¥, ces t√©moins garantissent la certitude
    witnesses = [2, 3, 5, 7, 11, 13, 17]
    if k < len(witnesses):
        witnesses = witnesses[:k]
    
    # Test de Miller-Rabin
    for a in witnesses:
        if a >= n:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

def efficient_modinv(a, m):
    """
    Calcule l'inverse modulaire a^(-1) mod m efficacement
    en utilisant l'algorithme d'Euclide √©tendu it√©ratif.
    """
    if gcd(a, m) != 1:
        raise ValueError("L'inverse modulaire n'existe pas")
    
    # Algorithme d'Euclide √©tendu it√©ratif
    x0, x1, y0, y1 = 1, 0, 0, 1
    a0, m0 = a, m
    
    while m0 > 0:
        q = a0 // m0
        a0, m0 = m0, a0 - q * m0
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    
    # Normaliser le r√©sultat pour qu'il soit positif
    return x0 % m

def find_coprime(n):
    """
    Trouve un nombre premier avec n en commen√ßant √† partir de 3.
    """
    e = 3
    while gcd(e, n) != 1:
        e += 2
    return e

# --------------------------
#  Chiffrement / D√©chiffrement
# --------------------------

def encrypt(message, public_key, salt, iv):
    """
    1. Salage caract√®re √† caract√®re.
    2. Pr√©fixe IV.
    3. Encodage Base64.
    4. Chiffrement RSA.
    5. Encodage Base64 du flux chiffr√©.
    """
    e, n = public_key

    # 1. Salage
    salted = ''.join(message[i] + salt[i % len(salt)] for i in range(len(message)))
    # 2. Pr√©fixe IV
    iv_msg = iv + salted
    # 3. Base64
    b64_plain = base64.b64encode(iv_msg.encode('utf-8'))

    # 4. RSA : bloc de taille fixe en octets
    block_size = math.ceil(n.bit_length() / 8)
    cipher_bytes = bytearray()
    for byte in b64_plain:
        c = pow(byte, e, n)
        # chaque bloc devient block_size octets big‚Äëendian
        cipher_bytes += c.to_bytes(block_size, byteorder='big')

    # 5. Encode en Base64 pour produire une cha√Æne ASCII
    return base64.b64encode(bytes(cipher_bytes)).decode('ascii')


def decrypt(cipher_b64, private_key, iv):
    """
    1. D√©codage Base64 du flux chiffr√©.
    2. D√©coupage en blocs et d√©chiffrement RSA.
    3. D√©codage Base64 pour retrouver IV+salted.
    4. Retrait IV et retrait sel.
    """
    d, n = private_key
    block_size = math.ceil(n.bit_length() / 8)

    # 1. Base64 ‚Üí bytes chiffr√©s
    try:
        cipher_bytes = base64.b64decode(cipher_b64)
    except Exception:
        raise ValueError("Erreur de d√©codage Base64 : message corrompu")

    # 2. D√©coupe en blocs et d√©chiffrement RSA
    plain_bytes = bytearray()
    for i in range(0, len(cipher_bytes), block_size):
        block = cipher_bytes[i:i+block_size]
        c = int.from_bytes(block, byteorder='big')
        m = pow(c, d, n)
        # m doit √™tre un octet unique (0‚Äì255)
        plain_bytes.append(m)

    # 3. Base64 inverse pour retrouver la cha√Æne iv+salted
    try:
        full = base64.b64decode(bytes(plain_bytes)).decode('utf-8')
    except Exception:
        raise ValueError("Erreur de d√©codage Base64 : message corrompu")

    # 4. Retrait IV et sel
    if not full.startswith(iv):
        raise ValueError("IV invalide !")
    salted = full[len(iv):]
    original = ''.join(salted[i] for i in range(0, len(salted), 2))

    # V√©rification d'int√©grit√© (optionnelle)
    # if simple_hash(original) != simple_hash(original): ...
    return original

# --------------------------
#  Fonctions d'interface utilisateur
# --------------------------

def asymmetric_encryption_menu(username):
    """Menu pour le chiffrement asym√©trique"""
    while True:
        try:
            choice = int(input("\nQue souhaitez-vous faire ?\n1. üîê Chiffrer un message\n2. üîì D√©chiffrer un message\n3. üîô Retour\nMon choix : "))
            
            if choice == 1:
                encrypt_message_for_user(username)
            elif choice == 2:
                decrypt_message_for_user(username)
            elif choice == 3:
                return
            else:
                print("‚ùå Veuillez entrer un choix valide.")
        except ValueError:
            print("‚ùå Veuillez entrer un chiffre valide.")

def encrypt_message_for_user(recipient_username):
    """Chiffrer un message avec la cl√© publique d'un utilisateur"""
    # Demander le nom du destinataire
    dest_username = input("\nPour qui est ce message? (nom d'utilisateur) : ")
    
    # V√©rifier si l'utilisateur existe
    if not user_exists(dest_username):
        print(f"‚ùå Utilisateur {dest_username} introuvable.")
        return
    
    # R√©cup√©rer la cl√© publique du destinataire
    user_data = get_user_keys(dest_username)
    public_key = user_data["public_key"]
    
    # Demander le message √† chiffrer
    message = demand_msg()
    
    # Param√®tres pour le chiffrement
    iv = "4O6g9trUcd4C3DnQ"
    salt = generate_salt()
    
    # Chiffrer le message
    try:
        cipher_b64 = encrypt(message, public_key, salt, iv)
        print(f"üîí Message chiffr√© pour {dest_username} : {cipher_b64}\n")
    except Exception as e:
        print(f"‚ùå Erreur lors du chiffrement : {str(e)}")

def decrypt_message_for_user(username):
    """D√©chiffrer un message avec la cl√© priv√©e de l'utilisateur"""
    # Demander le message chiffr√©
    cipher_b64 = demand_cipher_b64()
    
    # Demander la cl√© sym√©trique pour d√©chiffrer la cl√© priv√©e
    sym_key = demand_symmetric_key()
    
    # R√©cup√©rer et d√©chiffrer la cl√© priv√©e
    private_key = get_decrypted_private_key(username, sym_key)
    
    if not private_key:
        return
    
    # Param√®tres pour le d√©chiffrement
    iv = "4O6g9trUcd4C3DnQ"
    
    # D√©chiffrer le message
    try:
        decrypted = decrypt(cipher_b64, private_key, iv)
        print(f"üîì Message d√©chiffr√© : {decrypted}\n")
    except ValueError as err:
        print(f"‚ö†Ô∏è Erreur : {err}")
    except Exception as e:
        print(f"‚ùå Erreur lors du d√©chiffrement : {str(e)}")

# Cette fonction a √©t√© retir√©e car le chiffrement sym√©trique est g√©r√© par master_main.py

# --------------------------
#  Programme principal
# --------------------------

def main():
    print("\nüîê Programme de cryptographie asym√©trique üîë\n")
    
    # Demander l'identit√© de l'utilisateur
    username = demand_username()
    
    # V√©rifier si l'utilisateur existe d√©j√†
    if not user_exists(username):
        print(f"\nüë§ Bienvenue {username}, vous √™tes un nouvel utilisateur.")
        register_new_user(username)
    else:
        print(f"\nüëã Bon retour parmi nous, {username}!")
    
    # Menu principal
    while True:
        # Cryptographie asym√©trique directement sans choix
        asymmetric_encryption_menu(username)
            
        # Demander si l'utilisateur veut continuer
        continue_choice = input("\nVoulez-vous continuer? (o/n): ").lower()
        if continue_choice != 'o':
            print("\nüëã Merci d'avoir utilis√© notre programme de cryptographie. √Ä bient√¥t!")
            break

if __name__ == "__main__":
    main()